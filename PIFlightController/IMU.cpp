#include "IMU.h"
#include "math.h"

inline double to_degrees(double radians) {
    return radians * (180.0 / M_PI);
}


void IMU::setup(){
    RTIMUSettings *settings = new RTIMUSettings("RTIMULib");
    
    imu = RTIMU::createIMU(settings);
    
    if ((imu == NULL) || (imu->IMUType() == RTIMU_TYPE_NULL)) {
        printf("No IMU found\n");
        exit(1);
    }
    
    //  This is an opportunity to manually override any settings before the call IMUInit
    imu->IMUInit();
    
    //  this is a convenient place to change fusion parameters
    
    imu->setSlerpPower(0.02);
    imu->setGyroEnable(true);
    imu->setAccelEnable(true);
    imu->setCompassEnable(true);
    roll.setup(50);
    pitch.setup(25);
    yaw.setup(10);
    mX.setup(70);
    mY.setup(70);
    rollRate.setup(20);
    pitchRate.setup(20);
}

int IMU::updateIMU(){
    int sampleCount = 0;
    int sampleRate = 0;
    if (imu->IMURead()) {
        RTIMU_DATA imuData = imu->getIMUData();
        while (imu->IMURead()) {
            imuData = imu->getIMUData();
        }
        sampleCount++;
        roll.insert(to_degrees(imuData.fusionPose.x()) + rollComp);
        pitch.insert(to_degrees(imuData.fusionPose.y()) + pitchComp);
        yaw.insert(to_degrees(imuData.fusionPose.z()));
        
        mX.insert(imuData.accel.x()+  mXComp);
        mY.insert(imuData.accel.y() + mYComp);
        rollRate.insert(imuData.gyro.x());
        pitchRate.insert(imuData.gyro.y());
        //rotation(1,imuData.fusionPose.x(),imuData.fusionPose.y(),imuData.fusionPose.z());
        //printf("Test one piece: Roll = %f\n",to_degrees(imuData.fusionPose.data(0)));
        //printf("Sample rate %d: %s\r", sampleRate, RTMath::displayDegrees("", imuData.fusionPose));
        return 1;
    }else{
        return 0;
    }

}

void IMU::resetIMUFusion(){
    imu->resetFusion();
}


/*
//Rotate yaw of IMU to align roll and pitch with motors
void IMU::rotation(double yawShift, double rollInRad, double pitchInRad, double yawInRad){
    //To Coordinates
    double a = rollInRad, b = pitchInRad, c = yawInRad;
    double x = 0,y = 0,z = 0;
    double xPrime, yPrime, zPrime;
    x = cos(a)*cos(b) + cos(a)*sin(b)*sin(c) - sin(a)*cos(c) + cos(a)*sin(b)*cos(c)+sin(a)*sin(c);
    y = sin(a)*cos(b) + sin(a)*sin(b)*sin(c) + cos(a)*cos(c) + sin(a)*sin(b)*cos(c) - cos(a)*sin(c);
    z = -sin(b) + cos(b)*sin(c) + cos(b)*cos(c);
    xPrime = x*cos(yawShift)-y*sin(yawShift);
    yPrime = x*sin(yawShift) + y*cos(yawShift);
    zPrime = z;
    roll = to_degrees(atan2(yPrime,zPrime));
    pitch = to_degrees(atan2(xPrime,zPrime));
    yaw = to_degrees(atan2(yPrime,xPrime));
    printf("Roll: %f, Pitch: %f, Yaw %f\n",roll,pitch,yaw);
    fflush(stdout);
}
*/

int IMU::readIMU()
{
    int sampleCount = 0;
    int sampleRate = 0;
    uint64_t rateTimer;
    uint64_t displayTimer;
    uint64_t now;
    
    //  Using RTIMULib here allows it to use the .ini file generated by RTIMULib
    //Demo.
    //  Or, you can create the .ini in some other directory by using:
    //      RTIMUSettings *settings = new RTIMUSettings("<directory path>", "RTIMULib");
    //  where <directory path> is the path to where the .ini file is to be loaded/saved
    
    RTIMUSettings *settings = new RTIMUSettings("RTIMULib");
    
    RTIMU *imu = RTIMU::createIMU(settings);
    
    if ((imu == NULL) || (imu->IMUType() == RTIMU_TYPE_NULL)) {
        printf("No IMU found\n");
        exit(1);
    }
    
    //  This is an opportunity to manually override any settings before the call IMUInit
    imu->IMUInit();
    
    //  this is a convenient place to change fusion parameters
    
    imu->setSlerpPower(0.02);
    imu->setGyroEnable(true);
    imu->setAccelEnable(true);
    imu->setCompassEnable(true);
    
    //  set up for rate timer
    
    rateTimer = displayTimer = RTMath::currentUSecsSinceEpoch();
    
    //  now just process data
    
    while (1) {
        //  poll at the rate recommended by the IMU
        
        usleep(imu->IMUGetPollInterval() * 1000);
        
        while (imu->IMURead()) {
            RTIMU_DATA imuData = imu->getIMUData();
            sampleCount++;
            
            
            
            now = RTMath::currentUSecsSinceEpoch();
            
            //  display 10 times per second
            
            if ((now - displayTimer) > 100000) {
                printf("Sample rate %d: %s\r", sampleRate, RTMath::displayDegrees("", imuData.fusionPose));
                fflush(stdout);
                displayTimer = now;
            }
            
            //  update rate every second
            
            if ((now - rateTimer) > 1000000) {
                sampleRate = sampleCount;
                sampleCount = 0;
                rateTimer = now;
            }
        }
    }
}



